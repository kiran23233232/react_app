{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.component.jsx","components/search-box/search-box.componet.jsx","App.js","reportWebVitals.js","index.js"],"names":["Card","props","console","log","cardmonster","id","className","src","alt","name","CardList","wulfa","map","monster","SearchBox","placeholder","handleChange","type","onChange","App","hc3","state","monsters","searchField","bind","hc2","hc1","this","fetch","then","response","json","users","setState","e","target","value","filteredMonsters","filter","toLowerCase","includes","onClick","hc4","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6TAGaA,EAAO,SAACC,GAMrB,OAFAC,QAAQC,IAAIF,EAAMG,YAAYC,IAEvB,sBAAKC,UAAU,iBAAf,UAEA,qBAAKC,IAAG,+BAA0BN,EAAMG,YAAYC,GAA5C,0BAAwEG,IAAI,gBACpF,+BAAKP,EAAMG,YAAYC,GAAIJ,EAAMG,YAAYK,YCCvCC,EAAW,SAAAT,GAgBpB,OAdAC,QAAQC,IAAIF,GAOZC,QAAQC,IAAIF,EAAMU,OAOX,qBAAKL,UAAU,YAAf,SACVL,EAAMU,MAAMC,KAAI,SAAAC,GAAO,OAAI,cAAC,EAAD,CAAuBT,YAAaS,GAAzBA,EAAQR,UClBlCS,G,MAAY,SAAC,GAAgC,IAA/BC,EAA8B,EAA9BA,YAAYC,EAAkB,EAAlBA,aAEnC,OAAO,uBAEPV,UAAU,SAEVW,KAAK,SAASF,YAAaA,EAE3BG,SAcQF,MC6KGG,E,kDAtKX,aAAe,IAAD,8BAEV,gBA6CJC,IAAM,WAAQlB,QAAQC,IAAI,qBA3CtB,EAAKkB,MAAQ,CACTC,SAAU,CAEN,CAACb,KAAK,OAAOJ,GAAI,KAAK,CAACI,KAAO,OAAOJ,GAAI,KAAK,CAACI,KAAO,OAAOJ,GAAI,MAErEkB,YAAY,IAKxB,EAAKP,aAAe,EAAKA,aAAaQ,KAAlB,gBAYpB,EAAKC,IAAM,EAAKC,IAAIF,KAAT,gBA1BO,E,uCA6Cd,WAAQtB,QAAQC,IAAI,sB,iBAIpB,WAAQD,QAAQC,IAAIwB,Q,+BAEpB,WAAqB,IAAD,OAGhBC,MAAM,8CAA8CC,MAAM,SAAAC,GAAQ,OAAIA,EAASC,UAAQF,MAAK,SAAAG,GAAK,OAAI,EAAKC,SAAS,CAACX,SAASU,S,0BA+BjI,SAAaE,GAAI,IAAD,OAUZP,KAAKM,SAAS,CAACV,YAAcW,EAAEC,OAAOC,QAAO,WAAOlC,QAAQC,IAAI,EAAKkB,Y,oBAKrE,WAAU,IAAD,SAMwBM,KAAKN,MAA9BC,EANC,EAMDA,SAASC,EANR,EAMQA,YACXc,EAAmBf,EAASgB,QAAO,SAAAzB,GAAO,OAAIA,EAAQJ,KAAK8B,cAAcC,SAASjB,EAAYgB,kBAEhG,OACI,sBAAKjC,UAAU,MAAf,UAEA,mDAIA,uBAAOW,KAAK,SAASF,YAAY,kBAEjCG,SAAW,SAAAgB,GAYH,EAAKD,SAAS,CAACV,YAAcW,EAAEC,OAAOC,QAAO,WAAOlC,QAAQC,IAAI,EAAKkB,aAS7E,cAAC,EAAD,CACAN,YAAY,kBACZC,aAAcW,KAAKX,eAMnB,cAAC,EAAD,CAAUL,MAAO0B,IAGjB,wBAAQI,QAASd,KAAKD,MAAtB,qBACA,wBAAQe,QAASd,KAAKD,IAAtB,qBACA,wBAAQe,QAASd,KAAKF,IAAtB,qBACA,wBAAQgB,QAASd,KAAKP,IAAtB,qBACA,wBAAQqB,QAASd,KAAKe,MAAtB,qBACA,wBAAQD,QAASd,KAAKe,IAAtB,4B,GA7JEC,aC3BHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBjB,MAAK,YAAkD,IAA/CkB,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCAdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.349345d5.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport './card.styles.css';\r\nexport const Card = (props) => \r\n\r\n{\r\n\r\nconsole.log(props.cardmonster.id)\r\n\r\nreturn <div className='card-container'>\r\n    \r\n       <img src={`https://robohash.org/${props.cardmonster.id}?set=set2&size=180x180`} alt=\"cardmonster\" />\r\n       <h1>{props.cardmonster.id}{props.cardmonster.name}</h1>\r\n       </div> ;\r\n\r\n}","import React from 'react';\r\nimport './card-list.styles.css';\r\n\r\n\r\nimport {Card} from '../card/card.component';\r\n\r\n// export const CardList = (props) =>\r\n// {\r\n//     console.log(props)\r\n//     return (<div>{props.children}</div>)\r\n// }\r\n\r\n\r\nexport const CardList = props =>\r\n{\r\n    console.log(props)\r\n    \r\n\r\n    // TYPE 1 : here we are having children to be rendered defined in apps.js file \r\n    // return <div className='card-list'> {props.children} </div>;\r\n\r\n    // TYPE 2 : here we are not fetching children from app.js , here we are setting up the children directly \r\n    console.log(props.wulfa)\r\n    // return <div className='card-list'>\r\n    //         {props.wulfa.map(monster => <h1 key={monster.id}>{monster.email}</h1>)}\r\n    //         </div>;\r\n\r\n    // TYPE 3 : introducing Card Component \r\n    \r\n    return <div className='card-list'>\r\n{props.wulfa.map(monster => <Card key={monster.id} cardmonster={monster}/>)}\r\n</div>;\r\n\r\n}\r\n\r\n","import React from 'react' ;\r\n\r\nimport './search-box.styles.css'\r\n\r\n// what is a functional component \r\n\r\n// functional component dont have access to state ,beacuse they dont have access to the constructor because they dont have access to class constructor . \r\n// thye also dont have access to the life cycle methods . \r\n// this does not affect us much because sometimes we just want to render some html tags \r\n\r\n// So functional component is something that just gets some props and return html elements . \r\n\r\nexport const SearchBox = ({placeholder,handleChange}) => {\r\n\r\n    return <input \r\n    \r\n    className='search'\r\n    \r\n    type='search' placeholder={placeholder}\r\n                \r\n    onChange={ \r\n    // PROBLEM OF TY1 : \r\n    // when you type first letter into the search box , you will see searchField console logged as \"\" empty , this is due to state is asynchronous function call    \r\n    // asynchronous event is that which actually takes an indefinite amount of time that javascript does not know  , so the rest of the code will be running .. in the mean time if the asyncronous event finishes javascript will run the finished event . \r\n    // So setState will not happen immediately when we expect it to happen , \r\n    // the solution to that is to pass the second argument to the set state ., it is a call back that runs after the SetState is finished .  \r\n        \r\n            // TY1 Syntax \r\n            // this.setState({searchField : e.target.value});\r\n            // console.log(this.state);\r\n\r\n            // TY2 sytax below will solve the problem of TY1 , ie to put second argument and where we can do the console log .\r\n            // this.setState({searchField : e.target.value},() => {console.log(this.state);});\r\n            // TY 3 \r\n            handleChange\r\n            //  so the next thing is we dont want to put the setstate method to be called directly in the render method , we want to remove it from the render method \r\n            // because when ever setstate method is called them render method will be called and everything will be rerendered , to avoid such scenarios we have to move setstate method call out of the render method\r\n        }\r\n            \r\n            /> ;\r\n}","import React, {Component} from 'react';\r\nimport './App.css';\r\n\r\n\r\nimport {CardList} from './components/card-list/card-list.component';\r\nimport { SearchBox } from './components/search-box/search-box.componet'\r\n// Destructuring :\r\n\r\n// import React, {Component} from 'react';\r\n// class App extends Component {}\r\n\r\n// No Destructuring :\r\n\r\n// import React from 'react';\r\n// class App extends React.Component {}\r\n\r\n\r\n// ------------------------------------------------------------------\r\n\r\n\r\n// // how to add SSH to github associated to email in the git bash terminal \r\n// run   --> ssh-keygen -t rsa -b 4096 -C \"kiran.spark2323@gmail.com\" \r\n// go to --> /c/Users/udaya_bk/.ssh\r\n// run   --> ssh-agent\r\n// run   --> eval `ssh-agent -s`\r\n// run   --> ssh-add ./id_rsa\r\n\r\n//opt >  Identity added: ./id_rsa (kiran.spark2323@gmail.com)\r\n\r\n// now go to /c/Users/udaya_bk/.ssh and copy the contents of ./ida_rsa.pub\r\n// paste the contents of id_rsa.pub into git hub SSH and GPG keys in the settings by clicking ADD SSH KEY \r\n// my-app >  git init .\r\n// my-app > git remote add origin git@github.com:kiran23233232/react_app.git\r\n// my-app > yarn add gh-pages\r\n// go to packages.json and add \r\n// \"homepage\":\"https://kiran23233232.github.io/react_app\",\r\n//     \"predeploy\":\"yarn build\",\"deploy\": \"gh-pages -d build\"\r\n\r\n\r\nclass App extends Component {\r\n\r\n    constructor() {\r\n\r\n        super();\r\n\r\n        this.state = {\r\n            monsters: [\r\n\r\n                {name:'fank',id: '1'},{name : 'bank',id: '2'},{name : 'rank',id: '3'}\r\n            ],\r\n            searchField:''\r\n          }\r\n\r\n// when you define a custom function in the class example handleChange() , when we refer to this keyword in the custom function handleChange then it will not work \r\n// to make or to align the this keyword definition to the Component Class definition , we need to write the line below \r\nthis.handleChange = this.handleChange.bind(this);\r\n// the above method is more comprehensive means when ever we write a new costum function ,and if we use this keyword then we need bind it to the this keyword in the constructor by writing the above line .\r\n// how can we not write the above line and also make this keyword work in the custom function . \r\n// ANS : we need to write our custom function as Arrow function ie >>>> handleChange(e) => { this.setState({searchField : e.target.value},() => {console.log(this.state);}) }\r\n\r\n// NOTE : \r\n// highest level of context is window object in the console\r\n// go to console on the chrome and run >>>> const newFunc = () => console.log(this)  >>>> newFunc() \r\n\r\n\r\n//  lets play on these examples \r\n\r\nthis.hc2 = this.hc1.bind(this);\r\n\r\n    }\r\n\r\n// You see you remember how we got the render() method by extending into Component Class.\r\n// We also get a bunch of other methods that are called lifecycle methods.\r\n\r\n// What are lifecycle methods?\r\n\r\n// lifecycle methods , they're essentially methods that get called at different stages \r\n// of when this component gets rendered.\r\n\r\n// lets understand --> componentDidMount :\r\n// when component mounts meaning : mounting is essentially when react will put our component on the page or \r\n\r\n//Before our Component renders onto the DOM for the first time, react will call componentDidMount() method .\r\n// so what we can do we can make the data ready in the componentDidMount() method so that data is ready for the page . \r\n \r\n\r\n    hc1() { console.log('button 1 clicked');}\r\n\r\n    hc3 = () => { console.log('button 3 clicked');}\r\n \r\n    hc4() { console.log(this);}\r\n\r\n    componentDidMount() {\r\n\r\n        // fetch('https://jsonplaceholder.typicode.com/users').then( response => response.json()).then(users => console.log(users))\r\n        fetch('https://jsonplaceholder.typicode.com/users').then( response => response.json()).then(users => this.setState({monsters:users}))\r\n\r\n    \r\n\r\n    }\r\n\r\n//  TYPE 1 : in this case you have props and props children\r\n    // render() {\r\n\r\n    //     return (\r\n    //         <div className=\"App\"> \r\n\r\n    //         {/* the item listed below is the card component */}\r\n    //         {/* the key value pair defined here name='' is called as props */}\r\n    //         {/* One of the most important property of props is children , if there is no children then props.children will be null */}\r\n    //         {/* Children are those that you put between the  <CardList> --here-- <CardList/>*/}\r\n    //         {/* {this.state.monsters.map(monster => <h1>{monster.name}</h1>)} */}\r\n    //         {/* the reason why we need unique id<key={monster.id}> beacuse react needs to know what element it need to update , if there is any particular value that changes in the given the list then  to avoid rerendering everything , only changed value can be rerenderd  */}\r\n    //         {/* NOTE > Anytime you use the map() function inside of render, or you have a list of the same jsx elements one after another, they need a key attribute (and CRA will warn you about it if you miss it) */}\r\n\r\n    //         <CardList name='Mawa ek peg la'>\r\n    //         {this.state.monsters.map(monster => <h1 key={monster.id}>{monster.email}</h1>)}\r\n    //         </CardList>\r\n    //         </div>\r\n    //     )\r\n\r\n\r\n//  if you see , we are calling this.setState() method at multiple places , how about we write it only once and use it everywhere else by just using one thing \r\n// We can write our own method handleChange() \r\n// this.handleChange --> is same as   <   e => {  this.setState({searchField : e.target.value},() => {console.log(this.state);}) } >\r\n\r\n    handleChange(e) {\r\n\r\n// this keyword below here is undefined , so it will not work , beacuse context of this is unable to set here \r\n// we need to explicitly define what context it needs to be \r\n// so we need to define it in the constructor  beacuse the items in the constructor will run first . \r\n// we need to put --> \r\n// this.handleChange = this.handleChange.bind(this) in the constructor \r\n// this of component class is well defined so , in constructor the this keyword refers to the component class definiton of this , so \r\n// when we put the statement this.handleChange = this.handleChange.bind(this) in the constructor we are saying or binding the constructor context of this keyword to the this keyword of the handleChange . \r\n\r\n        this.setState({searchField : e.target.value},() => {console.log(this.state);})\r\n    \r\n    }\r\n\r\n//  in this case you have only Props , no children\r\n        render() {\r\n\r\n        \r\n\r\n        // what destructuring help us to do is to pull properties from object and set them to constant that we put in {}\r\n        //  so instead of palying with the actual state , we will assign it to internal constants to this function \r\n        const { monsters,searchField } = this.state ; \r\n        const filteredMonsters = monsters.filter(monster => monster.name.toLowerCase().includes(searchField.toLowerCase()))\r\n        //  the above line is equivalent of saying const monsters = this.state.monsters; const searchField = this.state.searchField ;\r\n            return (\r\n                <div className=\"App\"> \r\n\r\n                <h2> Monsters Rolodex</h2>\r\n                {/* the input box below serves to establish a search box to search items  based on name , when ever you type then onchange event is triggered */}\r\n                {/* We have to store the input into the SearchField item of the state so that we can propagate it across the components card , cardlist , so we can use the setState method here too*/}\r\n                {/* if you observe , when ever you type anything you are changing the state so whole code will rerun , you will see all console logs being outputed for each type of a new character of the input */}\r\n                <input type='search' placeholder='search monsters' \r\n                \r\n                onChange={ e =>\r\n                // PROBLEM OF TY1 : \r\n                // when you type first letter into the search box , you will see searchField console logged as \"\" empty , this is due to state is asynchronous function call    \r\n                // asynchronous event is that which actually takes an indefinite amount of time that javascript does not know  , so the rest of the code will be running .. in the mean time if the asyncronous event finishes javascript will run the finished event . \r\n                // So setState will not happen immediately when we expect it to happen , \r\n                // the solution to that is to pass the second argument to the set state ., it is a call back that runs after the SetState is finished .  \r\n                    {   \r\n                        // TY1 Syntax \r\n                        // this.setState({searchField : e.target.value});\r\n                        // console.log(this.state);\r\n\r\n                        // TY2 sytax below will solve the problem of TY1 , ie to put second argument and where we can do the console log .\r\n                        this.setState({searchField : e.target.value},() => {console.log(this.state);});\r\n\r\n                        //  so the next thing is we dont want to put the setstate method to be called directly in the render method , we want to remove it from the render method \r\n                        // because when ever setstate method is called them render method will be called and everything will be rerendered , to avoid such scenarios we have to move setstate method call out of the render method\r\n                    }\r\n                        \r\n                        }/>\r\n\r\n                {/*WE CAN WRITE THE ABOVE INPUT FUNCTIONALITY BY BUILDING A COMPONENT AND USE COMPONENT FOR SEARCH FUNCTIONALITY */}\r\n                <SearchBox \r\n                placeholder='search monsters' \r\n                handleChange={this.handleChange}/>\r\n                {/* here we change the props item directly to state item , so that we dont need to put anything in the children area */}\r\n                {/* We are setting here the props = {name : state[monsters] } */}\r\n                {/* All Monsters */}\r\n                {/* <CardList wulfa={this.state.monsters}/> */}\r\n                {/* Filtered Monsters Based on SearchField item */}\r\n                <CardList wulfa={filteredMonsters}/>\r\n                \r\n                {/* when you just refresh the browser click 1 button associated hc1() will run eventhough you did not click the click 1 button , because the render() function will run when the browser refreshes and also if there is any function call inside the render() that is hc1() , it will also automatically run  */}\r\n                <button onClick={this.hc1()}>click 1</button>\r\n                <button onClick={this.hc1}>click 2</button>\r\n                <button onClick={this.hc2}>click 3</button>\r\n                <button onClick={this.hc3}>click 4</button>\r\n                <button onClick={this.hc4()}>click 5</button>\r\n                <button onClick={this.hc4}>click 6</button>\r\n                </div>\r\n\r\n                \r\n            )\r\n\r\n}\r\n\r\n}\r\n\r\n\r\nexport default App;\r\n\r\n// NOTE 1:\r\n\r\n// Just a quick note to remember to use the back tick  ` \r\n// and NOT regular single or double quotes (' and \") for string \r\n// interpolation on our image src. This is an easy mistake to make as \r\n// you cannot interpolate the strings when using regular quotes, \r\n// you must use back ticks!\r\n\r\n\r\n// NOTE 2:\r\n\r\n// We do know that our only component is the app component.\r\n// Right.\r\n// We've only written this one single class based component, which is our app.\r\n// However, in REACT, what we want to do is we want to be able to break our code into smaller, reusable\r\n// pieces that are only focused on one responsibility.\r\n\r\n// EX 1 :\r\n\r\n// This search bar is its own component.\r\n// And in a way, because this card is itself, it doesn't really care about the other cards around it.\r\n// So there's got to be something that seems to be containing every single card on our page.\r\n// And that is going to be another component.\r\n\r\n// Now, one of the big things about components is that they take in something called props and props is\r\n// going to be the parameter that we get from our functional component.\r\n\r\n\r\n\r\n// this is a special keyword in javascript that references the context in which it is being invoked . \r\n// this.state refers to the state on the component Class where it is called .\r\n\r\n\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n// Replace the root element object with the App item ie App.js item \nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}